https://git-scm.com/book/ko/v2

# 형상관리 시스템은 왜 나오게 되었을까요?
	- 형상관리란 개발과정에서의 시작과 끝의 과정중 변경되는 모든 사항을 관리하는 작업.
	- 대표적인 형상관리 시스템 git / svn 
	- 단순하게 본다면 변경사항을 체계적으로 관리 하는 것이다.
    @ 형상관리 구성요소  4가지 :
	- 형상 식별 (Configuration Identification)
		: 시스템의 효율적인 개발관리를 위해 형상항목(SCI)을 정의하고 분류 하는 활동 
	- 형상 통제 (Configuration Control)
		: 소프트웨어시스템의 각 베이스라인별로 형상을 설정하고 변경하는 일을 체계적인 절차(변경통제위원회 CCB)에 의해 통제하고 관리하여 결정하는 절차
	- 형상 감사 (Configuration Audit)
		: 형상 항목이 요구사항에 맞도록 잘 변경되었는지 확인 하는 것 FCA와 PCa가 있다. 
소스코드를 검토하는 FCA는 실제 성능이 기능 기준선 (Functional Basline) 및 할당 기주선 (Allocated Basline)에 명시된 요구조건을 충족하는가를 확인하는 절차
	- 형상 기록 (Configuration Status Accounting) 
		: 앞의 3가지 호라동을 자료로 수집하고 기록, 결과의 내용을 데이터베이스화 하고 원하는 형태로 다양하게 이용할수 있도록 하는 활동 .

위에 4가지 요소가 이렇다 정도이지, 결국에는 형상관리는 모든 변동 사항을 체크하는 것이고, 이것이 실수를 줄이기 위한 방법 중 완성도가 높다.

형상관리 말고도 PMS(프로젝트 관리시스템) 방법론과 돈이나 진척률 등 프로젝트의 전체적인 사항을 관리하는 시스템, ITSM (IT Service Management) ITIL(IT Infrastructure Library) 프레임워크를 토대로 서비스를 계획, 제공, 운영, 제어 하는 전체적인 활동 시스템, ALM(apllication LifeCycle Management)개발의 요구사항 분석에서부터 아키텍쳐, 변경 관리 등 끝까지 모든 과정을 관리 등 다른 것도 존재하는데 , 주제가 다를 뿐 본질적으론 비슷하다.




#형상 관리의 장점 
	- 소스코드의 변경이력을 관리 할 수 있어서 추적성이 좋다.
	- 배포가 편리하다.
	- 여러사람이 동일한 소스코드를 공유해 개발할 수 있으며, 공유시에 발생하는 버전간의 충돌 문제등을 해결할 수 있다.
	- 장애 혹은 기능상 필요할 때 이전 버젼의 BaseLine으로 소프트웨어를 되돌릴 수 있다. 

# 형상 관리 사용 이유 요약
	- 가시성의 결핍 : 소프트 웨어는 무형물.
	- 통제의 어려움 : 가시성이 결핍된 상품의 제작은 통제가 어려움.
	- 추적의 어려움 : 프로젝트의 중간 목표들을 연결 시키고 개발 과정을 추적하기 어려움.
	- 감시의 미비 : 가시성과 추적성의 결핍은 프로젝트의 진행을 감시하기 어렵게 함.
	- 무절제한 변경 : 통제되지 않고 관리 되지 않는 소프트웨어의 무절제한 변경이 발생



#형상관리 시스템은 왜 나오게 되었을까요?
	
	- 가시성의 결핍 : 소프트 웨어는 무형물.
	- 통제의 어려움 : 가시성이 결핍된 상품의 제작은 통제가 어려움.
	- 추적의 어려움 : 프로젝트의 중간 목표들을 연결 시키고 개발 과정을 추적하기 어려움.
	- 감시의 미비 : 가시성과 추적성의 결핍은 프로젝트의 진행을 감시하기 어렵게 함.
	- 무절제한 변경 : 통제되지 않고 관리 되지 않는 소프트웨어의 무절제한 변경이 발생.



#git은 어떤 형상관리 시스템이고 어떤 특징을 가지고 있을까요? 분산형 형상관리 시스템이란 무엇일까요?

 - 깃은 소프트웨어를 개발하는 기업의 핵심 자산인 소스코드를 효과적으로 관리할 수 있게 도와주는 무료 공개 소프트웨어.
 - SVN 보다 여러 장점이 있어 SVN을 쓰던 개발 조직들은 하나둘씩 git으로 변경중.
- Git이 SVN과 다른 점은 분산형 관리 시스템이다.

- SVN  : 중앙 서버에 소스코드와 히스토리를 저장함.
- Git    : 소스코드를 여러 개발 PC와 저장소에 분산해서 저장.
 그래서 중앙 서버에 장애가 발생해도 로컬 저장소에 커밋을 할 수 있으며, 로컬 저장소들을 이용하여 중앙 저장소의 복원도 가능하다.
 - 사본을 로컬에서 관리하기 때문에 Git이 Svn에 비해 훨씬 빠르다.
( SVN 의 경우 변경 로그 하나를 보는 것도 인터넷을 경유해야한다고 한다.)

- 깃의 장점 
      1. 소스코드를 주고 받을 필요 없이, 같은 파일을 여러명이서 동시에 작업하는 병렬 개발이 가능하다.
      2. 즉 브랜치를 통해 개발한 뒤, 본 프로그램에 합치는 방식으로 개발 진행이 가능하다. 
      3. 분산 관리이기 때문에 인터넷 연결이 되지않아도 개발을 진행할 수 있다. 중앙 저장소에 문제가 생겨도 원상복구가 가능하다.
      4.  팀 프로젝트가 아닌, 개인 프로젝트일지라도 GIT을 통해 버젼 관리를하면 체계적인 개발이 가능해지고 프로그램이나 패치를 배포하는 과정도 간단해집니다. (pull 을 통한 업데이트, patch 파일 배포)

 깃의 특징을 아래와 같이 공식 문서에서 말하고 있다. 

# Distributed development
	-전체 개발 이력을 각 개발자의 로컬로 복사본을 제공 하고 변경된 이력을 다시 하나의 저장소로 복사한다.
	- 이러한 변경은 추가개발지점을 가져와, 로컬 개발 지점과 동일하게 병합 할 수 있다. 저장소는 Git protocol 및 Http로 쉽고 효율적 (특별한 웹서버 구성없이) 으로 접근 할 수 있다.

# Strong support for non-linear development
	- 신속하고 편리한 Branch 및 merge 지원, 비선형 개발 이력을 시각화하고 탐색할 수 잇는 강력한 도구를 제공.

# Efficient handling of large projects
	-Git은 매우 빠르고, 대형 프로젝트나 이력이 많은 작업에 매우 합리적이다. Git은 대ㅜ분의 다른 버젼 관리 시스템보다 빠르게 요청한다. 그리고 일부 작업에서는 더 빠르게 진행한다.
	-또한, 최근의 정상급 오픈소스 버젼관리 시스템보다 장기간의 수정내역을 매우 효율적인 압축방법을 사용한다.

# Cryptograhpic authentication of history
	- Git의 이력은 성공한 개발 이력의 commit에 의해 개정명으로 저장된다. 일단 그것이 배포되면, 그것을 모르고 예전 버젼으로 변경하는 것은 불가능하다. 그리고 그것들을 암호화 할 수 있다.

# Toolkit Design,
	- Unix의 전통에 따라, Git은 C로 작성된 많은 소규모 도구 모음이다. 그리고 많은 스크립트들이 기능 보강을 제공한다.
Git 은 새로운 기발한 작업을 위한 손쉬운 사용과 쉬운 스크립팅을 위한 도구를 제공한다.	

#Git GUI

 - 너무 많은 git 명령어를 자유자재로 외울 자신이 없을 땐 GUI를 사용할 수도 있다.

#git은 어떻게 개발되게 되었을까요? git이 분산형 시스템을 채택한 이유는 무엇일까요?

- git과 GitHub은 어떻게 다를까요?
	- Git은 형상 관리 도구(버전 관리 시스템)
      
	- GitHub는 형상 관리 도구 (버전 관리) 웹호스팅 서비스  

      - Git : 
	프로젝트를 진행하면서 소스코드나 USB나 메일로 주고 받는건 엄청난 낭비임과 동시에 보안성 위험이 있다.  
	그렇기 때문에 프로젝트를 진행 함에 있어 형상관리 도구를 사용한다.  
	형상관리 도구를 사용하면 변경을 쉽게 되돌릴 수 있다.  
	소스코드를 과거의 특정 시점으로 되돌리거나, 특정시점의 변경 사항을 취소하거나, 두 버젼의 소스 코드를 비교하는 등의 일이 가능하다.  

      - GitHub :  
	협업하고 있는 코드를 저장할 서버가 필요하다.  
	버전 관리 시스템을 지원하는 웹호스팅 서비스의 기능을 통해, push ,pull Request같은 이벤트에 반응하여 자동으로 작업(배포 등)을 실행 할수 있다.   

#git의 clone/add/commit/push/pull/branch/stash 명령은 무엇이며 어떨 때 이용하나요? 그리고 어떻게 사용하나요?

    # clone : 원격 Git 저장소 복제 / 로컬로 복제
	- 원격 Git  저장소의 주소Https혹은 SSH코드를 확인하고, git clone [Repo_URL OR SSH] [DIR]로 사용 가능하다.
	Dir 을 생략하면 현재 위치로 복제할 위치를 지정한다.	(이후 git remote-v로 현재 리모트 확인 가능함.)
	
	# add : 작업 디렉토리 상의 변경 내용을 스테이징 영역에 추가하기 위해 사용한다.
	위에서 말한것처럼	Commit 이전에 변경분을 모아두기 위한명령어이고 commit이 되기전에는 변경이력에 영향을 주지않는다.
	# git add <파일/디렉토리 경로>로 사용하면 작업 디렉토리의 변경 내용의 일부만 스테이징 영역에 넘기고 싶을때는 수정한 파일이나 디렉토리의 경로를 인자로 넘긴다.

	# git add . 으로 사용하면
	     현재 디렉토리의 모든 변경 내용을 스테이징 영역으로 넘기고 싶을때는 . 을 인자로 준다.
	
	# git add -A는
	     작업 디렉토리 내의 모든 변경 사항을 몽땅 스테이징 영역으로 넘기게 된다.
         작업 디렉토리 상에 어디에 위치하든 동일하게 모든 내용을 스테이징으로 넘긴다. 
         git add . 의 경우에는 실행된 디렉토리 이하에서만 내용을 포함하게 되며 해당 디렉토리 기준으로 상위 디렉토리의 변경은 포함하지 않는다. 만약에 git add . 를 프로젝트 최상위 디렉토리에서 실행한다고 하면 git add -A 와 동일한 효과를 내게 된다.

	# git add -p의 경우네는 각 변경 사항을 터미널에서 직접 눈으로 하나씩 확인하면서 스테이징 영역으로 넘기거나 제외시킬수가 있다. 변경내용이 많을 때에 변경 기록으로 나누어서 남기고 싶을 때 유용하게 사용할 수 있다.

	# commit : 파일 및 폴더의 추가/ 변경 사항들에 대한 기록을 한다.
	add 로 스테이징 영역(인덱싱되어있는) 에 들어있던 내용들을 시간 순으로 저장하며 최근 커밋부터 거슬러 올라가면 과거 변경 이력과 내용을 확인 할 수 있다. commit 을 하게 되면 해당 기록에 대한 이름으로 영문/숫자40자리로 이루어진 이름이 부여되어 이것을 id값으로 구분할 수 있다.

	# git commit 옵션으로는 -m -am 등이 있다. 
	
	# git commit -m 'message' 를 사용하면 commit에서 vim을 들어가 msg를 작성하는 작업을 skip하고 명령창에서msg를 바로 작성할수 있다.
	
	# git commit am 'message' 는 커밋이 된 이후에 다시 새버젼을 만들 경우 'add', 'vim에서 msg 작성하는 작업'을 명령창에서 바로 할 수 있다.

	# push 명령어는 origin 즉, 원격 저장소의 브랜치에 밀어올린다, 기록한다. 따라서 push를 할때에는 원하는 브랜치를 명시하고, 올리면 해당 브랜치에 기록할 수 있다. 
	 - git branch -M main
     - git push origin main <<
	기본적으로는 git push <저장소명> <브랜치명> 으로 사용한다.
	ex )  git push origin my-feature

	git clone을 통해 저장소를 복제했다면 일반적으로 origin이며 git remote 명령어를 통해서 정확한 저장소명을 알아낼 수도 있다.
	git remote
	origin   <<
	
    또한 git push를 날릴때마다 매번 저장소명과 브랜치명을 명시하는게 귀찮다면 -u 옵션을 사용하여서 최초 저장소명과 브랜치명만 입력하여 이후에 모든 추가 입력사항을 생략할 수 있다고 한다.
	
	예를 들어, 다음과 같이 저장소명과 브랜치명을 남기면서 -u옵션과 함께  git push명령어를 날리면	
    git push -u origin my-feature
	그 이후에 커밋한 코드 변경분을 원격 저장소에 올릴 때는 인자없이 git push만 입력해주면 된다.

	혹은 여러 브랜치를 변경하면서 작업을 하는 경우라면, 최초에 한번 인자를 넘기는 것도 힘들게 느껴질 수 있는데, 대부분의 경우에는 로컬저장소와 원격 저장소에서 동일한 브랜치 이름을 사용하기 때문에  항상현재 브랜치를 기준으로 git push 명령어가 작동한다면 매우 편리하다고한다.
이를 위해서는 약간의 설정이 필요하다.
 push.default 설정을  current로 설정해준다.
 git cofing --global push.default current  
이렇게 설정을 해두면 어느 브랜치에서 작업을 하든 git push 만 날리면 원격 저장소에 동일한 브랜치로 코드 변경분이 업로드된다.
	
	git pull을 사용하면 원격저장소의 변경된 데이터를 가져올 수 있다.
	pull한 데이터가 어떻게 반영되는지는 아래 간단한 문자도식을 ㅗ확인 해보자면  
	A -> B -> X-> Y(origin/master)

	A -> B(master)
	인 상황에서 원격 저장소의 커밋Y를 로컬로 가져오는 경우를 본다.
	이 상황은 단순히 'fatst-forward 병합' 이 이루어진다.
	이 내부의 'master'는 로컬 저장소의 'master' 브랜치, 'origin/master'는 원격 저장소 'origin'의 'master' 브랜치를 나타낸다.

	A-> B-> X-> Y(origin/master master)
그러나 로컬 저장서의 'master 브랜치에서도 변경 사항이 생긴 경우, 양쪽의 변경을 통합할 필요가 있다.

	A->B->X->Y (origin /master)
	          |    |  
	A->B->C->D  (master)
이때 pull을 실행하여 소스를 병합할수 있다.  충돌하는 변경사항이 없을 경우 자동적으로병합 커밋이 만들어지지만, 충돌이 있을 경우에는 충돌난 부분을 수동으로 해결한 다음 직접 commit을 해야한다.
	
	branch의 명령어의 경우
	git branch 현재는 master 브랜치만 존재한다. (master : 최초 레포지토리 생성 후 커밋하면 자동으로 생기는 브랜치) 
	*가 붙어있는 브랜치가 현재활성화된 브랜치이다.

	git branch -v 를 사용하면 브랜치의 마지막 커밋 메세지를 확인 할 수 있다. 
	git branch <브랜치명> 을 사용해서 브랜치를 생성할 수 있다.
	git checkout <브랜치명>으로 브랜치를 이동 할 수 있다.
	git checkout -b <브랜치명> 은 브랜치를 생성하고 바로 이동할 수 있다.
	git branch -d <브랜치명>로 브랜치를 삭제할 수 있다.


	stash 는 임시저장과 비슷한 맥락이다.
	예를 들어서 내가 어떤 작업을 하고 있다가 다른 요청이 들어와 잠시 작업을 멈추고 브랜치를 변경해야한다고 하는 상황에서 내가 마무리하지 않은 작업에 대해서 commit하는 것이 껄끄러운 경우가 충분히 있을 수 있다.   (  
		Stashed Changes
		         |
		Workign Directory  - stage-> Staged Snapshot - commit -> committed SnapShots
		)
	아직 마무리되지 않은 작업을 잠시 스택에 저장할 수 있도록 하는 명령어이다.
	이를 commit하지 않고 나중에 다시 꺼내와서 마무리할 수 있도록 해준다.

	- git stash 명령을 사용하면 워킹 디렉토리에서 수정한 파일들만 저장한다.
	- stash  란 아래에 해당하는 파일들을 보관해두는 장소이다.
		1. modified 이면서 Tracked 상태인 파일 
			- Tracked 상태인 파일을 수정한 경우
			- Tracked : 과거에 이미 commit 하여 스냅샨에 넣어진 관리 대상의 파일
		2. Staging Area 에 있는 파일 (Staged 상태의 파일)
			- git add 명령을 실행한 경우
			- Staged 상태로 만들려면 git add명령을 실행해야 한다.
	git Stash 명령어를 통해 stash를 스택에 만들어 하던 작업을 임시로 저장한다.
		- 예를 들어서 파일2개를 수정하고 그 중하나는 Staging Area에 추가한다. 아직 작업 중인 2개의 파일은 commit 할게 아니기 때문에 모두 stash에 넣는다.
			1. index.html: Staging Area에 있는 파일 (Staged 상태의 파일)
			2. lib/simplegit.rb:Modifed 이면서 Tracked 상태인 파일


	Ex) // working directory에 있는 파일의 상태 확인
	$ git status
	Changes to be committed:
	(use "git reset HEAD <file>..." to unstage)
	modified:   index.html
	Changes not staged for commit:
	(use "git add <file>..." to update what will be committed)
	(use "git checkout -- <file>..." to discard changes in working directory)
	modified:   lib/simplegit.rb
	
	git Stash / git Stash save 명령어로 스택에 새로운 stash가 만들어진다.
	이 과정을 통해서 Working directory는 깨끗해진다.
	
	git stash list를 통해서 stash에 넣은 목록을 확인 할 수 있다.
	git stash apply 를 통해서 작업을 다시 가져올 수 있다.
	ex) //가장 최근의 stash를 가져와 적용시킨다.
	git stash apply 
	//  stash 이름 (ex. stash@{2})에 해당 하는 stash를 적용한다.
	git stash apply [stash 이름]
	 위 명령어로는 Staged 상태였던 파일을 자동으로 다시 Staged 상태로 만들어주지 않는다.
	-index 옵션을 주어야 Staged 상태까지 복원한다. 이를 통해 원래 작업하던 파일의 상태로 돌아올 수 있다.
	//Staged 상태까지 저장
	git stash appyl --index

	stash  제거하기 
	git stash drop
	apply 옵션은 단순히 stash를 적용하는 것으로, 해당 stash는 스택에 여전히 남아있다.
	스탹에 남아 있는 stash 는 위의 명령어를 사용하여 제거할 수 있다.

	//가장 최근의 stash를 제거한다.
	git stash drop
	//stash 이름(ex. stash@{2})에 해당하는 stash를 제거한다.
	git stash drop [stash 이름]
	
	만약 저장되어 있던 stash를 가져와 적용과 동시에 해당 stash를 제거하고 싶으면
	git stash pop 명령을 사용하면 된다.
	// apply + drop의 형태	
	git stash pop

	실수로 잘못 stash를 가져와 적용했다면 
	git stash show -p | git apply -R을 사용한다.
	// 가장 최근의 stash를 사용하여 패치를 만들고 그것을  거꾸로 적용한다.
	git stash show -p | git apply -R
	//stash 이름 (ex. stash@{2}) 에 해당하는 stash 를 이용하여 거꾸로 적용한다.
	git stash show -p [stash 이름]  | git apply -R
	
	Alias를 사용할 수도 있다.
	stash-unapply 명령어로 간단하게 사용할 수 있다.
	git config --global alias.stash-unapply '! git stash show -p | git apply -R'
	git stash apply
	#... work work work
	//  alias로 등록한 stash 되돌리기 명령어
	git stash upapply
	

#git의 Object, Commit, Head, Branch, Tag는 어떤 개념일까요? git 시스템은 프로젝트의 히스토리를 어떻게 저장할까요?
	- git의 개체는 크게 4가지 commit, Tree, Blob, Tag로 나뉜다.
	git은 내부적으로 이 4가지 오브젝트 타입을 관리한다.
	
	오브젝트들은 .git/objects에 개별적인 파일들로 존재한다.
	하나의 commit, 하나의 tree, 하나의 blob 그리고 하나의 tag는 각각 하나의 파일이다.

	두개의 commit 은 당연히 두개의 파일이다.
	
	오브젝트가 담긴 파일의 이름은 git 이 오브젝트 컨텐츠의 내용을 참고하여 생성하는 40자리 문자열이다.
	예로 git 에 "hello.txt"라는 파일을 하나 추가하면,
	"hello.txt"라는 이름의 오브젝트를 생성하는 것이 아니라
	"hello.txt"의 내용 전부를 해시테이블에 넣어
	40자리의 해시값을 뽑아내어 오브젝트 파일 이름으로 사용한다.

	그렇다면 "hello.txt"라는 이름은 어디에 저장되는 것일까?
	"hello.txt"를 위한 오브젝트인 blob에는 파일이름인 "hello.txt"라는 문자열로 저장되지 않는다.
	
	대신 디렉토리 구조를 나타내는 tree 오브젝트에서 "hello.txt"라는 문자열을 찾을 수 있습니다.
	
	(이는 리눅스 파일 시스템에서 흔히 사용하는 inode - dentry의 관계와 동일합니다.)

	오브젝트 들은 하나의 파일로 .git/objects에 차곡차곡 쌓이게 되는데
	한 디렉토리에 너무 많은 파일이 있으면 파일 시스템의 성능이 저하 될 수 있기때문에
	오브젝트의 파일 이름 중 앞 2글자는 디렉토리 이름으로 사용 ,
	나머지 38글자는 파일이름으로 사용하게 된다.

	blob(binary large object)
	- 타입 : blob 타입
	- 사이즈 : 컨텐츠의 용량을 bytes로 표시
	- 컨텐츠 : blob의 컨텐츠에는 텍스트, 이미지, 음악 혹은 단순 이진 파일철머 다양한 형식의 파일이 저장될 수 있다.
	파일이름이나 파일 형식은 blob에 저장되지 않는다.
	파일의 메타정보를 제외한 파일의 내용 전체를 품는다.

	tree
	- 타입 : tree 타입
	- 사이즈 : 트리 오브젝트의 용량을 bytes로 표시
	- tree 객체 : 하위 디렉토리의 트리 객체를 재귀적으로 참조할 수 있다.
	- blob 객체 : 한 디렉토리에 있는 모든 blob을 담고 있다.
	객체에 대한 접근권한, 파일이름은 여기서 관리한다.
	
	commit 
	-작성자
	-커밋 실행자
	-커밋 날짜	
	- 로그메시지
	-tree 객체 : 해당 커밋에서의 dir/file의 상태를 알 수 있다.

	tag 
	-객체 종류
	- 태그 이름
	- tagger
	- 태그메시지
	- PGP 서명정보
	
	git은 이러한 오브젝트의 상태정보를 확인 할 수 있는 명령어가 노출되어 있다.
	git cat-file을 오브젝트에 사용하여 오브젝트가 품고 있는 정보를 자세히 알아보려 합니다.

	ex)git cat-file -p 44cac0afe16f0819bba6cc2332b9418ba3c1ce8b

	git 에서 HEAD란 현재 체크아웃된 커밋을 가리킨다. 즉 현재 작업중인 커밋이다.
	HEAD는 항상 작업트리의 갖아 최근 커밋을 가리킨다. 
	작업 트리에 변화를 주는 git 명령어들은 대부분 HEAD를 변경하는 것으로 시작합니다.
	일반적으로 HEAD는 브랜치의 이름을 가리킵니다.

	HEAD 를 분리한다는 것은 HEAD를 브랜치 대신 커밋에 붙이는 것을 의미한다.
	(git checkout 커밋이름 으로 커밋으로변경할수 있다.)

	깃에서 태그란 
		커밋을 참조하기 쉽도록 알기 쉬운 이름을 붙이는 것을 말한다고 한다.
		한번 붙인 태그는 브랜치 처럼 위치가 이동하지 않고 고정된다.
		Git 에서는 일반적으로 이름 정보만을 갖는 태그 ('Lightweight tag')와 보다 상세한 정보를 포함하는 주석태그 이 두가지 태그를 사용할 수 있습니다.
		- 일반태그 (Lightweight tag)
			: 이름만 붙일 수 있어요.
		- 주석태그(Annotated tag)
			: 이름을 붙일 수 있어요
			: 태그에 대한 설명도 포함할 수 있어요.
			: 서명도 넣을 수 있어요.
			: 이 태그를 만든 사람의 이름, 이메일과 태그를 만든 날짜 정보도 포함시킬 수 있어요.
		보통 '릴리스 브랜치 (Release branch)에서는 주석 태그를 사용하여 설명이나 서명을 넣은 보다 상세한 정보를 포함하는 태그를 사용하고  로컬에서는 일시적으로 사용하는 ' 토픽 브랜치'에서만 이름만 만들어 붙이는 태그를 사용한다고 한다.
		또한 태그 이름을 지정하여 checkout 하거나 reset(아직 안 배웠어요!) 함으로써, 간단하게 과거의 특정 상태로 되돌릴 수 있답니다!

		Git에서의 브랜치는  독립적으로 어떤 작업을 진행하기 위한 개념이다. 필요에 의해 만들어지는 각각의 브랜치는 다른 브랜치의 영향을 받지 않기 때문에 여러 작업을 동시에 진행할 수 있다.

		또한 이렇게 만들어진 브랜치는 다른 브랜치와 병합(MERGE)함으로써 작업한 내용을 다시 하나의 브랜치로 모을 수 있습니다.
		브랜치를 사용하여 동시에 여러 작업을 진행할 때 작업의 흐름을 하눈에 파악 할 수 있습니다.

		여러명이서 동시제 작업을 할때에 다른 사람의 작업에 영향을 주거나 받지 않도록, 먼저 멩니 브랜치에서 자신의 작업 전용 브랜치를 만듭니다.	
		그리고 각자 작업을 진행한 후, 작업이 끝난 사람은 메인 브랜치에 자신의 브랜치의 변경 사항을 적용합니다.
		이렇게 함으로써 다른 사람의 작업에 영향을 받지 않고 독립적으로 특정 작업을 수행하고 그 결과를 하나로 모아 나가게 됩니다.
		이러한 방식으로 작업할 경우 '작업 단위' 즉 브랜치로 그 작업의 기록을 중간중간에 남기게 되므로 문제가 발생했을 경우에는 원인이 되는 작업을 찾아내거나 그에 따른 대책을 세우기 쉬워진다.


	#깃의 내부구조
		- git의 내부는 일종의 단순한 key-value 데이터베이스이다.
		- git 프로젝트의 .git 디렉토리 안에는 git 버전관리에 필요한 데이터들이 저장된다.
		
	#Content-addressable Key-Value Storage
		git은 버젼 관리에 필요한 데이터를 key-value 형태의 오브젝트로 변환한다.
		이때 ket는 데이터를 SHA-1 알고리즘을 이용한 체크섬이 되고 Value는 데이터를 zlib으로 압축한 값이 된다.
	
	SHA-1 해시를 사용하여 체크섬을 생성하면 체크섬은 160비트가 되고 16진수로 표현하면 40자리의 문자열이된다. 
	git 은 이 40자리 문자열 중 앞의 2자리는 디렉토리 명으로 나머지 38자리는 파일명으로 사용한다.
	즉, git은 원본 데이터의 체크섬을 파일명으로 원본 데이터를 zlib 압축한 값을 파일데이터로 저장하고 이를 object라고 합니다.
	
	git 은 타입을 나타내는 헤더와 내용을 합쳐 SHA-1 체크섬을 계산합니다.
	
	Object의 내용을 보면 zlib으로 압축되어 있기 때문에 내요을 바로 확인할 수 없습니다.
	git cat-file 명령어를 사용하면 오브젝트의 타입과 내용을 확인할 수 있습니다.
	# 타입
	git cat-file -t <object>
	# 내용
	git cat-file -p <object>

	위에 말한 Object들은 버전관리를 하게 될 리소스만을 의미하는 것은 아니며, 
	먼저 언급한대로 4가지의 데이터를 object화 시켜 .git/object 하위에 저장한다.
	
	blob Object는 프로젝트에서 버전 관리하는 파일의 데이터 입니다.

	AAA의 내요을 갖는 A.txt 를 생성하고 커밋을 하게 되면 Blob Object가 저장된다.
	(	git은 스냅샨 기반의 VCS이다.)

	만약 A.txt 를 AAAA로 수정하고 커밋하게 된다면 위와 같이 새로운 Blob Object가 생성된다.
	즉, git은 파일의 각 버젼을 Blob object로 저장하게 됩니다.

	Tree Object는 한마디로 표현했을때 상태(버전을) 갖는 디렉토리 트리 노드 입니다. 루트 디렉토리로 시작
	각 디렉토리가 갖고 있는 Blob object와 또 다른 디렉토리인 Tree Object가 생성됩니다.

	Blob Object를 다시 보면 Blob Object는 파일명을 갖고 있지 않고 데이터만 갖고 있습니다.
	Tree Object는 어떤 버젼의 데이터와 하위 트리노드를 갖고 있는지 프로젝트의 구조를 만들어 줍니다.
	
	즉, 루트 Tree Object만 알면 해당 버젼의 파일셋을 만들 수 있습니다.
	
	Commit object
	Tree Object를 설명하면서 마짐가에 루트 Tree Object를 알면 특정 버젼을 구성할 수 있다고 했다.
	Commit Object는 커밋에 대한 정보와 해당 커밋의 루트 Tree Object에 대한 정보를 저장한다.
	스냅샷은 누가 언제 왜 저장했는지에 대해서는 정보가 아무것도 없다.
	이런 정보는 커밋 개체에 저장된다.

	만약 부모 커밋이 존재하면 아래와 같이 부모커밋의 체크섬키가 포함이 된다.
	
	tree 353165696a9a0f6c84030e3e85f6bf3791666ba1
	parent 76a96d10af1506324ec22ecbbc4740d5a730c186
	author juicyjusung <juicyjusung@gmail.com> 1622342120 +0900
	committer juicyjusung <juicyjusung@gmail.com> 1622342120 +0900


	Git Refs
	Object를 정리해 봅시다.
	 새로운 파일혹은 변경된 파일이 커밋 되었을 경우 Blob object 생성
	 커밋된 스냅샹의 Hierarchy구조를 그리는 TreeObject 생성
	 커밋 정보와 해당 스냅샷의 루트 트리 노드키를 포함하는 Commit Object를 생성

	정리한 대로 우리는 원하는 버전의 Commit Object의 체크섬만 알고 있으면 해당 버젼을 구성할 수 있다.
	또한 Commit Object는 부모 커밋의 체크섬도 가지고 있으므로 현재 Commit Object까지의 일련의 스냅샷 	히스토리를 추적할 수 있습니다.
	
	git의 모든 Object는 SHA-1 값을 사용한다. 인간의 입장에선 SHA-1 값은 직관적이지 않다.
	만약 Commit object를 가리키는 쉬운 이름으로 된 포인터가 있으면 어떻게 될까?
	우리는 그 이름으로 해당 커밋의 스냅샷 혹은 그 커밋까지의 히스토리를 조회할수 있다.
	git 이러한 것들을 Refs라고 부른다. Refs는 .git/refs 아래에 구성된다.

	특정 커밋을 가리키는 알기 쉬운 이름의 포인터가 추적하기 원하는 스냅샷의 흐름의 가장 마지막 커밋을 		가리키면 어떨까? 이것이 우리가 사용하는 브랜치이다.

	브랜치를 생성하면 .git/refs/heads에 refs가 생성된다.

	refs/tag	
	Objects 섹션에서 설명을 하지 않은 마짐가 object가 있다. 바로 tag Object이다.
	Tag Object는 누가 언제 태그를 달았는지 태그 메시지는 무엇이고 어떤 커밋을 가리키는지에 대한 정보가	포함된다.
	
	얼핏 듣기엔 특정 버전을 구성할 수 있는 Commit Object랑 비슷할 수 있지만 
	Tag Object는 Tree Object가 아니라 Commit Object를 가리키는 것이 그 둘의 차이이다.
	태그는 Lightweight tag와 annotated tag 두 종류가 있다.  이 둘의 차이는 위의 그림과 같이 
	LightWeight tag는 Commit Object 를 바로 가리키고, Annotated Tag는 Tag Object를 가리킵니다.

	HEAD 
	커밋을 하거나 새로운 브랜치를 생성할 때 기준이 되는 커밋을 어떻게 알 수 있을까요?
	git은 .git/HEAD 에 현재 기준이 되는 refs값을 기록한다.
	일반적으로 브랜치의 refs 값을 갖겠지만  SHA-1 값으로도 사용할 수 있다.
	HEAD를 refs가 아닌 다른 커밋의 SHA-1로 설정하고 커밋하면 어떻게 될까

	당연히 커밋을 할때 HEad 의 커밋이 기준이 된다는 것을 알 수 있다.
	
	git은 변경사항이 있으면 완전히 새로운 Blob Object를 생성하기 때문에 최적화를 위해 적절한 시점 (Loose 객체가 너무 많을때, Push 할때, Git gc 커맨드를 실행할때) 에 델타화 및 압축을 실행합니다.
	https://www.juicylog.com/git-internals 참고


		
#리모트 git 저장소에 원하지 않는 파일이 올라갔을 때 이를 되돌리려면 어떻게 해야 할까요?
	IntelliJ 를 사용시에 .out폴더를 .gitignore에 넣지 않고 원격 저장소에 push 했다고 가정 했을 시를 전제로 한다.
	(IntelliJ의 .out 폴더: 빌드/ 컴파일 시 .class 파일이 포함된 프로젝트의 출력이 포함되는 위치)

	1. 원격 저장소에서 파일 삭제하기
		이미 github remote에 push했기 때문에 로컬의 저장소에서 파일을 삭제해도 원격 저장소에서는 삭제되지않는다.
	
		git rm VS git rm -cached
		//원격 저장소와 로컬 저장소에 있는 파일을 삭제한다.
		git rm [File Name]
		// 원격 저장소에 있는 파일을 삭제한다. 로컬 저장소에 있는 파일은 삭제하지 않는다.
		git rm --cahced [File Name]
		
		이와 같이 git rm-cached [File Name]명령어를 이용하여 저장소에서 잘못올라간 파일을 삭제해야 한다.
		
		// .idea/modules.xml 파일 삭제
		git rm --cached .idea/modules.xml
		// .idea 폴더 하위의 모든 파일 삭제
		git rm --cached -r .idea /
		
	.gitignore 설정하기
		만약 .gitignore 가 제대로 설정되어 있지 않다면 .gitignore를 설정하여 다음에는 개인이 관리해야되는 파일들이 원격 저장소에 올라가지 않도록 해야한다. 한 .gitignore는 git add 명령어 전에 설정되어 있어야 적용이 가능하다는 것을 알아두자.
	
	원격 저장소에  적용
	-버전 관리에서 완전히 제외하기 위해서는 반드시 commit 명령어와 push를 수행해야한다.
	
	// 버전 관리에서 완전히 제외하기 위해서는 반드시 commit명령어를 수행해야 한다.
	git commit -m "Fixed untracked files"
	// 원격 저장소 (origin )에 push
	git push origin master

    @깃 스테이지 에리어
	git add 명령어를 사용하면 스테이징 에리어로 들어가게 된다고 한다.  이 부분은 SVN같은 기존의 버전관리 시스템에서는 없던 개념이기 때문에 Git으로 처음 넘어온 분들이 헷갈려하는 부분이기도 하다.
	스테이징 영역은 작업 디레토리와 Git 저장소의 변경 이력 사이에 징검다리 같은 역할을 하고, 작업 디렉토리는 아직 커밋할 준비가 안된 변경 내용을 자유롭게 수정할 수 있는 공간인 반면에, 스테이징 영역은 커밋할 준비가 된 변경 내용이 Git 저장소에 기록되기 전에 대기하는 장소라고 생각할 수 있다. git add 명령어를 사용하면 현재 작업 디렉토리에 있는 모든 또는 일부 변경내용을 스테이징 영역으로 이동시킬 수 있다.
git commit 명령어가 변경 이력을 남길 시점에는 작업 디렉토리에 있는 변경 내용은 고려하지 않고, 스테이징 영역에 넘어온 변경 내용만 사용되기 때문에 이 두개의 공간을 서로 헷갈려하면 안된다.

이렇게 작업 디렉토리와 스테이징을 구분하면 변경 이력을 남길때 작업 디렉토리에 있는 변경 내용을 한번에 몽땅 기록않고, 조금씩 나누어서  기록할수 있다는 장점이 있다고 한다. 이를 통해서 각 변경 기록에 논리적으로 하나의 변경 사항을 담기가 용이한데 이렇게 하면 나중에 버그를 추적하거나 변경 이력을 롤백 할때도 이점이 있다.


# Mercurial은 어떤 형상관리 시스템일까요? 어떤 장점이 있을까요?
	git과 달리 Mercurial은 처음에는 Linux 커널의 소스 코드를 유지보수하고 관리하는데에 사용된 	BitKeeper라고 하는 상용 소스 코드 관리 시스템을 대체하는 오픈 소스 였다.
	그 이후에 Mercurial은 많은 오픈 소스 및 상용 프로젝트에서 사용되는 인기 있는 VCS 시스템
	으로 발전되었다.  
	Mercurial을 사용하는 프로젝트로는 Mozilla, IcedTea 및 MoinMoin wiki가 있다.
	일반적으로 VCS 시스템은 변경할 수 있고 추적할 수 있는 각 소스 코드 콜렉션을 저장소로 참조한다. 중앙화된 VCS 시스템인 CVS 및 SubVersion과 같은 전통적인 VCS 시스템과 분산 시스템인 Mercurial 및 git과 같은 더 유연한 VCS 시스템 간의 중요한 차이점은 개발자가 저장소와 상호 작용하는 방식에 있다. 개발자는 클라이언트/서버 모델을 사용하여 중앙화된 VCS 시스템과 상호 작용한다. 이런 경우에는 소스 코드 로컬 사본의 변경된 코드가 중앙 저장소에 있는 모든 사본이 변경될 수 있고, 다른 사본과 함께 공유될 수 있는 저장소가 된다.
사실상 분산 VCS 시스템에는 중앙의 마스터 저장소라는 개념이 없지만, 해당 소프트웨어의 마스터 비전을 빌드하고, 테스트 및 유지보수 하는데 필요한 하나의 저장소를 둔다는 정책에 따라 거의 언제나 하나의 마스터 저장소가 정의된다.
	# Mercurial 사용이유
		Mercurial은 시작하기 쉬운 작지만 강력한 분산 VCS 시스템으로 VCS 전문 사용자가 사용하는 데 필요한 고급 명령을 제공한다. Mercurial의 분산 특성을 이용하면 로ㅓ컬에서 프로젝트를 쉽게 작업할 수 있을뿐 아니라 로컬 커미트를 통해 변경된 코드를 추적하고 관리할 수 있으며 이러한 변경 코드를 필요할 때마다 원격저장소에 저장할 수 있다.
최신 분산 VCS 시스템 중에서 Mercurial과 가장 근접한 VCS는 git이다.
Mercurial과 git의 차이점은 아래와 같다.

내장된 다수의 실행 취소 조작 : Mercurial의 revert, backout 및 rollback 명령을 이용하면 특정 파일의 이전 버전이나 커미트된 이전의 변경 세트를 쉽게 되돌릴 수 있다.
Git에는 일반적으로 이해하기 어려운 구문을 사용하는 하나의 내장 revert명령이 있다.

내장 웹 서버 : Mercurial은 간단한 통합 웹 서버를 제공하며 이 웹 서버를 이용하면 다른 개발자가 가져오기 작업을 수행할 저장소를 신속하게 호스트할 수 있다. 밀어넣기 동작을 수행하려면 보안을 무시하거나 SSL( Sercure Sockets Layers)을 지원하도록 더 복잡하게 설정해야한다.

복사 및 이동 조작을 수행하는 동안 히스토리 유지 : Mercurial의 copy및 move 명령은 모두 완전한 히스토리 정보를 유지하는 반면에 Git은 어느 경우에도 히스토리를 유지하지 않는다.

브랜치 : Mercurial은 자동으로 모든 브랜치를 공유하지만, Git은 로컬에서 브랜치를 작성하거나 원격 저장소에 있는 특정 브랜치에 맵핑하여 각 저장소에 자체 브랜치를 맵핑하여 각 저장소에 자체 브랜치를 설정한다.

글로벌 및 로컬 태그 : Mercurial은 저장소 간에 글로벌 태그를 지원하며, 이 태그를 이용하면 브랜치를 설정하지 않아도 코드 개발 과정의 특정 시점에 대한 정보를 쉽게 공유 할 수 있다.

windows플랫폼에 대한 기본적인 지원 : Mercurial은 Python으로 작성 되었으며,
Microsoft , Windows 시스템에서 지원된다. 따라서 Mercurial은 Windows 실행 파일로 사용 가능하다, Windows에서 Git을 사용하는 방법은 더 복잡하다.
자동 저장소 압축 : Git을 사용하는 경우에는 사용자가 저장소를 명시적으로 압축하고 가비직 컬렉터를 작동해야 하지만,Mercurial에서는 이러한 조작이 자동으로 수행된다.
그러나 코드 베이스가 같은 경우에 Mercurial의 저장소는 Git의 저장소보다 더 큰 경향이 있다.
